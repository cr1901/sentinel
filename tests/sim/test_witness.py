import pytest
from sentinel.top import Top

from conftest import RV32Regs, CSRRegs


# Semi-autogenerated (script not provided b/c it's a one-off) from a yosys
# witness file for a failed reg_ch0 test at around f3d3e315b7.
#
# While looking at why the trace failed, which was a bug in my formal harness,
# I found _another_ bug that is a legitimate bug in Sentinel.
# Specifically, none of the sim tests before this altered dat_r in the middle
# of an instruction, which seems to hide a few bugs. This particular set
# of dat_r and acks is _intended_ to perform the following insns:
#
# csrrc x8, mstatus, x4
# andi x1, x8, 40
#
# which writes to the nonexistant CSR with address 0b0001.
#
# The witness file is provided for reference; eventually the goal is to
# autogenerate TBs from witness files (and allow the TBs to evolve
# independent of the witness files as Sentinel changes).
@pytest.fixture
def csrrc_bad_rd_process(mod):
    m = mod

    async def proc(ctx):
        await ctx.tick()

        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b0)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b110000000011111111111111111111)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b110000000011111111111111111111)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b110000000111111111111111111111)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b110000000111111111111111111111)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b11110100010000100111111111111111)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b1)
        ctx.set(m.bus.dat_r, 0b110000000000100011010001110011)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b10000001110011)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b1)
        ctx.set(m.bus.dat_r, 0b110010000100010010001001110011)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b110000100000010100000000010011)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b100100011011010100110011)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b110100001011000000000110100011)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b110100000010011010000101110011)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b10010000000011)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b110000001000000000000001101111)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b100001110000111110011)
        await ctx.tick()

        assert ctx.get(m.datapath.csr.adr) == 0b0000

        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b1000100001000000101001101100011)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b1)
        ctx.set(m.bus.dat_r, 0b10100001000111000010010011)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b10110000001000001001011111101111)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b1)
        ctx.set(m.bus.dat_r, 0b100001001101000010010100)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b110000010000001000000100001111)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b11001000001000010110111)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b11111110110110000011000010011100)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b11011101010100101000111110010011)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b0)
        ctx.set(m.bus.dat_r, 0b10000010100111000000001101101)
        await ctx.tick()
        ctx.set(m.bus.ack, 0b1)
        ctx.set(m.bus.dat_r, 0b0)
        await ctx.tick()

        expected_regs = RV32Regs(R8=0x00001800, PC=8 >> 2)
        actual_regs = RV32Regs.from_top_module(m, ctx)
        assert expected_regs == actual_regs

        expected_regs = CSRRegs()
        actual_regs = CSRRegs.from_top_module(m, ctx)
        assert expected_regs == actual_regs

    return proc


# class WitnessTop(Elaboratable):
#     def __init__(self):
#         self.cpu = Top()

#     def elaborate(self, plat):
#         m = Module()
#         m.submodules.cpu = self.cpu

#         dummy = Signal()
#         m.d.sync += dummy.eq(dummy)

#         return m


@pytest.mark.parametrize("mod,clks", [(Top(), 1.0 / 12e6)])
def test_csrrc_bad_rd(sim, csrrc_bad_rd_process, ucode_panic):
    sim.run(testbenches=[csrrc_bad_rd_process],
            processes=[ucode_panic])


# This doesn't actually have a witness trace. This is just the best place to
# put it. Due to a microcode typo, which m5meta sometimes doesn't diagnose,
# the CSRRCI instruction would sometimes clear extra bits for CSRs that
# are implemented as FFs rather than BRAM. This wasn't detected until I put a
# design on FPGA! I made a test case by running test_rust for 20000 (sic)
# cycles with the typo present, and the typo fixed, finding when their traces
# diverged, and minimizing a test case.
@pytest.fixture
def csrrci_bad_write(mod):
    m = mod

    async def proc(ctx):
        ctx.set(m.datapath.regfile.m_data[10], 1)
        ctx.set(m.datapath.regfile.m_data[0x20], 0x00001808)

        await ctx.tick().until(m.bus.cyc & m.bus.stb &
                               m.control.mem.insn_fetch)

        # mret- force MPIE to 1, as in the trace this is originally from.
        ctx.set(m.bus.dat_r, 0x30200073)
        ctx.set(m.bus.ack, 1)
        await ctx.tick()
        ctx.set(m.bus.ack, 0)

        await ctx.tick().until(m.bus.cyc & m.bus.stb &
                               m.control.mem.insn_fetch)

        # csrrci x10, mstatus, 8
        ctx.set(m.bus.dat_r, 0x30047573)
        ctx.set(m.bus.ack, 1)
        await ctx.tick()
        ctx.set(m.bus.ack, 0)

        await ctx.tick().until(m.bus.cyc & m.bus.stb &
                               m.control.mem.insn_fetch)

        # lui x11, 1
        ctx.set(m.bus.dat_r, 0x000015B7)
        ctx.set(m.bus.ack, 1)
        await ctx.tick()
        ctx.set(m.bus.ack, 0)

        # Due to a typo in microcode "a_src => alo_o", MSTATUS.MPIE was being
        # cleared when it shouldn't!
        #
        # This wasn't caught until deploying on FPGA; I have some assumptions
        # around interrupt-handling in RISC-V Formal that must prevent this
        # from being detected. Use as a handwritten test for now until I
        # come up with a better mechanism to detect any other (?) interrupt
        # misbehavior.
        expected_regs = CSRRegs(MSTATUS=0b11000_1000_0000)
        actual_regs = CSRRegs.from_top_module(m, ctx)
        assert expected_regs == actual_regs

    return proc


@pytest.mark.parametrize("mod,clks", [(Top(), 1.0 / 12e6)])
def test_csrrci_bad_wr(sim, csrrci_bad_write, ucode_panic):
    sim.run(testbenches=[csrrci_bad_write],
            processes=[ucode_panic])
