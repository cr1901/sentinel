import pytest
from amaranth import Elaboratable, Module, Signal
from sentinel.top import Top

from conftest import RV32Regs, CSRRegs


# Semi-autogenerated (script not provided b/c it's a one-off) from a yosys
# witness file for a failed reg_ch0 test at around f3d3e315b7.
#
# While looking at why the trace failed, which was a bug in my formal harness,
# I found _another_ bug that is a legitimate bug in Sentinel.
# Specifically, none of the sim tests before this altered dat_r in the middle
# of an instruction, which seems to hide a few bugs. This particular set
# of dat_r and acks is _intended_ to perform the following insns:
#
# csrrc x8, mstatus, x4
# andi x1, x8, 40
#
# which writes to the nonexistant CSR with address 0b0001.
#
# The witness file is provided for reference; eventually the goal is to
# autogenerate TBs from witness files (and allow the TBs to evolve
# independent of the witness files as Sentinel changes).
@pytest.fixture
def csrrc_bad_rd_process(sim_mod):
    sim, m = sim_mod

    def proc():
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b0)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b110000000011111111111111111111)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b110000000011111111111111111111)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b110000000111111111111111111111)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b110000000111111111111111111111)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b11110100010000100111111111111111)
        yield
        yield m.cpu.bus.ack.eq(0b1)
        yield m.cpu.bus.dat_r.eq(0b110000000000100011010001110011)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b10000001110011)
        yield
        yield m.cpu.bus.ack.eq(0b1)
        yield m.cpu.bus.dat_r.eq(0b110010000100010010001001110011)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b110000100000010100000000010011)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b100100011011010100110011)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b110100001011000000000110100011)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b110100000010011010000101110011)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b10010000000011)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b110000001000000000000001101111)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b100001110000111110011)
        yield

        assert (yield m.cpu.datapath.csr.adr_w) == 0b0000

        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b1000100001000000101001101100011)
        yield
        yield m.cpu.bus.ack.eq(0b1)
        yield m.cpu.bus.dat_r.eq(0b10100001000111000010010011)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b10110000001000001001011111101111)
        yield
        yield m.cpu.bus.ack.eq(0b1)
        yield m.cpu.bus.dat_r.eq(0b100001001101000010010100)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b110000010000001000000100001111)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b11001000001000010110111)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b11111110110110000011000010011100)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b11011101010100101000111110010011)
        yield
        yield m.cpu.bus.ack.eq(0b0)
        yield m.cpu.bus.dat_r.eq(0b10000010100111000000001101101)
        yield
        yield m.cpu.bus.ack.eq(0b1)
        yield m.cpu.bus.dat_r.eq(0b0)
        yield

        expected_regs = RV32Regs(R8=0x00001800, PC=8 >> 2)
        actual_regs = yield from RV32Regs.from_top_module(m)
        assert expected_regs == actual_regs

        expected_regs = CSRRegs()
        actual_regs = yield from CSRRegs.from_top_module(m)
        assert expected_regs == actual_regs

    return proc


class WitnessTop(Elaboratable):
    def __init__(self):
        self.cpu = Top()

    def elaborate(self, plat):
        m = Module()
        m.submodules.cpu = self.cpu

        dummy = Signal()
        m.d.sync += dummy.eq(dummy)

        return m


@pytest.mark.module(WitnessTop())
@pytest.mark.clks((1.0 / 12e6,))
def test_csrrc_bad_rd(sim_mod, csrrc_bad_rd_process, ucode_panic):
    sim, m = sim_mod
    sim.run(sync_processes=[csrrc_bad_rd_process, ucode_panic])
